console.log("1" + 2 + 3); //конкатенация строк
console.log(1 + 2 + "3"); //сначала происходит сложение чисел, а затем конкатенация строк
console.log("1" - 2); //произошло преобразование строкив число. знак минус заставляет js преобразовать строкув число
console.log("1" + - 2); //конкатенация строк. -2 считается числом
console.log("1" + "1" - "1"); // конкатенация строк. "1" + "1" - "1" = "11" - "1" = 10 (в последнем действии знак минус заставляет js преобразовать строку в число)
console.log("foo" + - "bar"); // -"bar" нельзя преобразовать в число и поэтому получается fooNaN. ошибка преобразования приводит к NaN
console.log(0 == "0"); // == не строгое сравнение. "0" приводит к числу
console.log(0.5 + 0.1 == 0.6); // это точное вычисевычисление и пожтому true (0.6 == 0.6)
console.log(0.1 + 0.2 == 0.3); // здесь наоборот при 0.1 + 0.2 = 3.00..004
console.log(true + true + true == 3); // true = 1 поэтому true + true + true = 1 + 1 + 1 => 1 + 1 + 1 = 3
console.log(true == 1); // == не строгое сравнение, а т.к. true = 1 => при true == 1 равняется true
console.log(true === 1); // === строгое сравнение и сравнивает типы true - boolean, 1 - number
console.log(1 < 2 < 3); // 1 < 2 = true; true < 3 (1 < 3) = true
console.log(3 > 2 > 1); // 3 > 2 = true; true > 1 (1 > 1) = false
console.log(9007199254740991 + 1 == 9007199254740991 + 2); // 9007199254740991 максимальное целое число, до которого можно безопасно пользоваться. после превышения начинаются ошибки округления. поэтому при +1 и +2 число получается таким 9007199254740992
console.log(Math.sqrt(-1) == Math.sqrt(-1)); // корень из -1 = NaN => NaN == NaN = false. NaN - "не число", а не конкретное число
